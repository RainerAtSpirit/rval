---
name: Working with objects
order: 3
menu: Introduction
route: /introduction/factories
---

# Working with objects and arrays

So far we only used stand-alone reactive values to capture our state.
But in real world applications we will need complex objects or state trees.
But suprisingly, RVal however doesn't offer a primitive to work with objects or array.
Instead:

_consider every object or array as an immutable collection of reactive values_

By keeping objects and arrays themself immutable, it turns out that the mental model remains much simpler,
and the API surface that is needed to apply reactivity is much[^1] smaller.

But, that doesn't RVal is awkward of inconvenient when working with objects.
Instead, it turns out that using objects, which are structurally immutable, but contain stateful reactive values, are presently convenient to work with.

Let's start a bit simple with an object that captures the state of a `Todo` item (with apologies for the uninspired example):

```javascript
const title = val('Get coffee')
const done = val(false)

const myFirstTodo = {
  title,
  done,
}

title.done(true)
console.log(title.done())
```

Pretty straight forward eh? Note that we used only `const` values, and that `myFirstTodo` itself should be treated as an immutable objects to keep the conceptuel model simple.
(In fact, it would be recommended to use `Object.freeze(myFirstTodo)`, but it turns out that RVal will take care of that as well in most cases, as we will discover later).

## A first object factory

Probably you don't want to create multiple todo's in your application, intead of one.
To ease that process we can make a _factory_ funtion:

```javascript
function createTodo(initialTitle) {
  const title = val(initialTitle)
  const done = val(false)
  return {
    title,
    done,
  }
}

const myFirstTodo = createTodo("Get coffee")
myFirstTodo.done(true)
```

Ok, that was easy! But our factory function can do more than just instating some reactive values and combining them into an object.
We can add define derived data using `drv`, and actions using `act`, and make them part of the object as well:

```javascript
function createTodo(initialTitle) {
    const title = val(initialTitle)
    const done = val(false)
    const asMarkdown(() => done() ? " * [x] ~" + title() + "~" : " * [ ] " +title())
    const toggle = act(() {
        done(!done())
    })

    return {
        title, done, toggle, asMarkdown
    }
}
```

So, we now have a factory that creates an immutable object, containing some reactive values, derivations and actions. 
Note that we are only creating `const`s in these listing, and we neatly avoided using `this`, which might save some headaches down the road![^2]

Let's put our code to the test and create a `sub` to observe the effects of our state updates:

```javascript
const myFirstTodo = createTodo("Get coffee")
sub(myFirstTodo.asMarkdown, md => {
    console.log(md)
}

myFirstTodo.title("Get coffee and cookie")
// Prints: * [ ] Get coffee and cookie

myFirstTodo.toggle()
// Prints: * [x] ~Get coffee and cookie~
```

## Combining factories



## Using classes

Freezing

[^1]: In MobX, roughly 75% of the code base is dealing with decorators, making plain data structures observable and dealing with the various different ways that people have to work with objects.
[^2]: For _super_ performance critical applications (measure before optimizing!), one could use `Object.create` and store actions on the `prototype`, leveraging `this` and avoid creating a closure per action per instance.
